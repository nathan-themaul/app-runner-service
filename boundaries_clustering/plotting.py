import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import numpy as np

###### Visualisation functions #####
def plot_dbscan_clusters(dataset, labels):
    """
    Plots the clusters identified by DBSCAN.

    :param dataset: The dataset used for clustering (numpy array).
    :param labels: The labels generated by DBSCAN for each point in the dataset.
    """
    # Identify unique labels
    unique_labels = set(labels)
    n_clusters = len(unique_labels) - (1 if -1 in labels else 0)

    # Generate a color map
    colors = [plt.cm.Spectral(each) for each in np.linspace(0, 1, len(unique_labels))]

    # Plot each cluster with its corresponding color
    for k, col in zip(unique_labels, colors):
        if k == -1:  # Noise points are colored black
            col = [0, 0, 0, 1]

        class_member_mask = (labels == k)
        xy = dataset[class_member_mask]
        plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col), markeredgecolor='k', markersize=6)

    # Set the title of the plot
    plt.title('Number of clusters: %d' % n_clusters)
    plt.show()

# Function to visualize the lane formation process
def plotLaneFormation(lanes, currentPointA, currentPointB, iteration, allPoints, processedPoints):
    colors = list(mcolors.TABLEAU_COLORS.values())
    plt.figure(figsize=(20, 10))

    # Plot existing lanes
    for i, lane in enumerate(lanes.values()):
        color = colors[i % len(colors)]
        for pointA, pointB in lane:
            plt.plot([pointA[0], pointB[0]], [pointA[1], pointB[1]], color=color, marker='o')

    # Highlight the current pairing
    if currentPointA and currentPointB:
        plt.plot([currentPointA[0], currentPointB[0]], [currentPointA[1], currentPointB[1]], color='black', marker='o', linestyle='--')

    # Plot unattributed points
    unattributedPoints = [point for point in allPoints if tuple(point) not in processedPoints]
    if unattributedPoints:
        unattributedPoints = np.array(unattributedPoints)
        plt.scatter(unattributedPoints[:, 0], unattributedPoints[:, 1], color='gray', label='Unattributed Points', s=50)

    plt.title(f'Lane Formation Iteration {iteration}')
    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    plt.legend()
    plt.grid(True)
    plt.show()

def plot_merged_clusters(groupedPoints):
    """
    Plots the merged clusters with distinct colors.

    :param groupedPoints: A dictionary with groups as keys and list of points as values.
    """
    # Pre-defined set of colors
    colors = list(mcolors.TABLEAU_COLORS.values())  

    # Set up the figure
    plt.figure(figsize=(10, 10))

    # Plot each group with a different color
    for i, (group, points) in enumerate(groupedPoints.items()):
        color = colors[i % len(colors)]  # Cycle through colors if not enough
        points_array = np.array(points)
        plt.scatter(points_array[:, 0], points_array[:, 1], color=color, label=f'Group {group}', s=50)

    # Set plot title and labels
    plt.title('Visualization of Merged Clusters')
    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    plt.legend()
    plt.grid(True)

    # Display the plot
    plt.show()


def adjust_color_lightness(color, amount=0.5):
    """
    Adjust the lightness of the given color.

    :param color: A tuple representing an RGB color.
    :param amount: The amount to adjust the lightness (1.0 keeps the color the same, 
                   < 1.0 darkens it, > 1.0 lightens it).
    :return: A tuple representing the adjusted RGB color.
    """
    try:
        c = colorsys.rgb_to_hls(*color[:3])
        return colorsys.hls_to_rgb(c[0], max(0, min(1, amount * c[1])), c[2])
    except Exception:
        return color

def plot_lanes(boundaries):
    """
    Plots lanes with distinct colors. Points belonging to two lanes are colored differently.
    Each set of points is labeled by the lane(s) they belong to.

    :param boundaries: A dictionary where each key represents a boundary,
                  and the value is a dictionary containing coordinates and lanes info.
    """
    colors = list(mcolors.TABLEAU_COLORS.values())

    # Create a Matplotlib figure and axis with Mercator projection
    fig, ax = plt.subplots(figsize=(10, 10))

    # Store all coordinates for setting the plot limits later
    all_coords = []

    for boundary, data in boundaries.items():
        coordinates = data['coordinates']
        lane_info = data['lanes']

        # Function to create a unique color index from the lane tuple
        def get_color_index(lane_tuple):
            return hash(str(lane_tuple)) % len(colors)

        # Determine the color based on the lane information
        if len(lane_info) == 1:
            # Single lane
            color = colors[get_color_index(lane_info[0])]
        else:
            # Multiple lanes
            color = 'black'  # Or any other color that signifies multiple lanes

        # Plot each set of coordinates
        x_coords, y_coords = zip(*coordinates)
        ax.plot(x_coords, y_coords, color=color, marker='o', label=f'Boundary {boundary} Lanes {lane_info}')

        # Add coordinates to the all_coords list
        all_coords.extend(coordinates)

    # Set labels and title
    ax.set_title('Lanes Visualization')
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')

    # Add the Google Maps satellite background
    ctx.add_basemap(ax, crs="EPSG:4326", source="https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}", zoom=16)

    # Adjust the limits
    x_coords, y_coords = zip(*all_coords)
    ax.set_xlim(min(x_coords) - 0.01, max(x_coords) + 0.01)
    ax.set_ylim(min(y_coords) - 0.01, max(y_coords) + 0.01)

    ax.legend()
    plt.show()

def plot_lanes_with_smoothed_lines(smoothed_boundaries, lanes={}, nodes=[], num_points=250):
    """
    Plots the original and smoothed boundaries with distinct colors, lanes centerlines, and nodes.

    :param smoothed_boundaries: A dictionary with each key representing a boundary,
                                containing both original and smoothed coordinates and lane info.
    :param lanes: A dictionary of lanes with their centerline information.
    :param nodes: A list of nodes, each with location and connected lanes.
    """
    colors = list(mcolors.TABLEAU_COLORS.values())

    plt.figure(figsize=(10, 10))

    # Plot points and smoothed lines for each boundary
    for boundary_key, data in smoothed_boundaries.items():
        color = colors[hash(str(data["lanes"])) % len(colors)]

        # Plot original points
        original_points = data.get('original_points')
        if original_points:
            x_coords, y_coords = zip(*original_points)
            plt.scatter(x_coords, y_coords, color=color, marker='o', label=f'Boundary {boundary_key} Original')

        # Plot smoothed lines
        smoothed_points = data.get('smoothed_points')
        if len(smoothed_points) == 0:
            print('len 0')
            continue
        x_coords, y_coords = zip(*smoothed_points)
        plt.plot(x_coords, y_coords, color=color, linewidth=2, label=f'Lane {data["lanes"]} Boundary {boundary_key}')

    # Plot centerlines
    for lane_key, data in lanes.items():
        if data['centerline']:
            x_coords, y_coords = zip(*data['centerline'])
            plt.plot(x_coords, y_coords, color='black', linestyle='--', linewidth=2, label=f'Centerline Lane {lane_key}')

    # Plot nodes and their connections
    for node in nodes:
        node_x, node_y = node['location']
        plt.scatter(node_x, node_y, color='red', marker='x', label='Node')

        for connection in node['connections']:
            end_x, end_y = connection['line'][0]
            plt.plot([node_x, end_x], [node_y, end_y], color='green', linestyle=':', linewidth=1)




    plt.title('Boundaries, Centerlines, and Nodes Visualization')
    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    # plt.legend()
    plt.grid(True)
    plt.show()

def plot_lanes_with_centerlines(smoothed_lanes, num_points=500):
    """
    Plots the boundaries and centerlines for each lane.

    :param smoothed_lanes: Dictionary of lanes with smoothed boundary and centerline splines.
    :param num_points: Number of points to use for plotting the splines.
    """
    plt.figure(figsize=(12, 8))

    for laneKey, laneData in smoothed_lanes.items():
        # Plot boundaries
        for groupKey, groupData in laneData.items():
            if groupKey != 'centerline':  # Skip the centerline key
                spline_x, spline_y, max_distance = groupData['spline_x'], groupData['spline_y'], groupData['boundary_max_distance']
                if max_distance == 0:
                    continue
                distances = np.linspace(0, max_distance, num_points)
                x_coords = spline_x(distances)
                y_coords = spline_y(distances)
                plt.plot(x_coords, y_coords, label=f'Lane {laneKey} Boundary {groupKey}')

        # Plot centerline
        if 'centerline' in laneData:
            spline_center_x, spline_center_y, max_distance = laneData['centerline']['spline_x'], laneData['centerline']['spline_y'], laneData['centerline']['centerline_max_distance']
            if max_distance == 0:
                    continue
            distances = np.linspace(0, max_distance, num_points)
            x_centerline = spline_center_x(distances)
            y_centerline = spline_center_y(distances)
            plt.plot(x_centerline, y_centerline, '--', label=f'Lane {laneKey} Centerline', color='black')

    plt.title('Lanes with Boundaries and Centerlines')
    plt.xlabel('X Coordinate')
    plt.ylabel('Y Coordinate')
    plt.legend()
    plt.grid(True)
    plt.show()